\documentclass[a4paper,12pt]{article}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{graphicx}
\graphicspath{ {img/} }
\usepackage{listings}
\usepackage{color}
\definecolor{lightgray}{rgb}{.95,.95,.95}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=JavaScript,
   backgroundcolor=\color{lightgray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b
}


\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{tqvj24}
\chead{Written Answers}
\rhead{Computer Graphics}

\begin{document}

\section*{Question 1}
\subsection*{a)}
% Difference between attribute, uniform and varying in shaders
\begin{description}
    \item[Uniform]
    A global variable that cannot be changed by the shaders, and is dependent upon the geometric primitive in use.
    % per primitive, basically doesn't change
    \item[Attribute]
    A global variable that cannot be changed by the shader, which is dependent upon the current vertex, and therefore is only available within the vertex shader.
    % per vertex
    \item[Varying]
    A variable that stores data that has been interpolated, so can vary pixel by pixel. The vertex shader is able to modify this, however the fragment shader is not.
    % interpolating (fragments)
\end{description}

\subsection*{b)}
\begin{lstlisting}[title=Colour and vertices in same array]
var polygonVerticesAndColours = new Float32Array([
     0.0,  1.0,  -4.0,  0.4,  1.0,  0.5,
    -0.5, -1.0,  -4.0,  0.4,  0.7,  0.4,
     0.5, -1.0,  -4.0,  0.5,  0.4,  0.5,
     0.0,  1.0,  -2.0,  1.0,  1.0,  0.4,
    -0.5, -1.0,  -2.0,  0.3,  1.0,  0.5,
     0.5, -1.0,  -2.0,  1.0,  0.4,  0.4
]);
var n = 6; // 6 vertices in this polygon

// Create a buffer object
var vertexColorbuffer = gl.createBuffer();
if (!vertexColorbuffer) {
  console.log('Failed to create the buffer object');
  return -1;
}

// Write the vertex information and enable it
gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorbuffer);
gl.bufferData(gl.ARRAY_BUFFER, polygonVerticesAndColours, gl.STATIC_DRAW);

var FSIZE = polygonVerticesAndColours.BYTES_PER_ELEMENT;

// Assign the buffer object to a_Position and enable the assignment
var a_Position = gl.getAttribLocation(gl.program, 'a_Position');
if(a_Position < 0) {
  console.log('Failed to get the storage location of a_Position');
  return -1;
}

gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 6, 0);
gl.enableVertexAttribArray(a_Position);

// Assign the buffer object to a_Color and enable the assignment
var a_Color = gl.getAttribLocation(gl.program, 'a_Color');
if(a_Color < 0) {
  console.log('Failed to get the storage location of a_Color');
  return -1;
}
gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 6, FSIZE * 3);
gl.enableVertexAttribArray(a_Color);
\end{lstlisting}

\subsection*{c)}
\includegraphics[width=0.95\textwidth]{scene-graph}
\newpage
\subsection*{d)}
% (Reference: WebGL Prog. Guide Chapter 4, Table 4.1) Suppose drawBox(m) is a
% function to draw a transformed box according to the transformation matrix m. That is, if m is
% a rotation matrix, the function will draw a rotated box.
% Explain the meaning of the following code segment and state the result obtained:
\begin{lstlisting}[title=Explaining the meaning]
    m.setRotate(angle, 0.0, 1.0, 0.0);
    m.translate(1.0, 3.0, -5.0);
    drawBox(m);
\end{lstlisting}
\subsubsection*{i.}

The above code block ensures that the matrix $m$ is rotated around the y axis by $angle$ degrees from $0$, regardless of current rotation before this code block, and then is translated by $+1.0$ in the x axis, $+3.0$ in the y axis, $-5.0$ in the z axis, relative to where m was before this code block. The matrix is then drawn.
 % [5 marks]
\subsubsection*{ii.}
% ii) Explain whether you will get the same result if m.setRotate() has been replaced by
% m.rotate().
In this case, replacing $setRotate$ by $rotate$ will \textit{not} give the same result. $setRotate$ is done before 'chain-able' transformations, however $rotate$ is not, $rotate$ would be 'chained' with $transform$, which would mean that the transform is actually carried out first, as the 'chain-able' commands are carried out in reverse order. Additionally, if the matrix already had some rotation applied, $setRotate$ overwrites this, but $rotate$ adds to it.\\\\In this case, having replaced $setRotate$ by $rotate$, the matrix would be transformed away from it's current position, and then rotated, still about the origin. If we assume it started centered about $(0,0,0)$, it would be moved to $(1.0, 3.0, -5.0)$, and then rotated about the origin, around the y axis, causing it to move in a big circle, as opposed to turning 'on the spot'.

\section*{Question 2}
The included files \texttt{tqvj24.html} and \texttt{tqvj24.js} are my code for this question.

\end{document}
